#! /mnt/netdev/tom.minor/Nuke/Nuke10.0Dev.000001b/libnuke-10.0.so -nx
version 10.0 v0.000001b
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="25" w="1055" h="1030" screen="0">
        <splitter orientation="1">
            <split size="491"/>
            <splitter orientation="2">
                <split size="322"/>
                <dock id="" activePageId="Error Console.1">
                    <page id="uk.co.thefoundry.scripteditor.2"/>
                    <page id="Error Console.1"/>
                </dock>
                <split size="650"/>
                <dock id="" activePageId="Properties.1" focus="true">
                    <page id="Properties.1"/>
                </dock>
            </splitter>
            <split size="556"/>
            <splitter orientation="2">
                <split size="579"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="393"/>
                <dock id="" hideTitles="1" activePageId="DAG.1">
                    <page id="DAG.1"/>
                </dock>
            </splitter>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /mnt/netdev/tom.minor/dev/blinktracer/sdf_test.nk
 format "1280 720 0 0 1280 720 1 HD_720"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
}
BlinkScript {
 inputs 0
 kernelSourceFile /mnt/netdev/tom.minor/dev/blinktracer/arse.rpp
 recompileCount 424
 ProgramGroup 1
 KernelDescription "2 \"TestKernel\" iterate pixelWise 35521d44dc13a30f1347619e7e7d0fde6222081a8cfdf340fe52d2311e242a95 1 \"dst\" Write Point 11 \"Image Resolution\" Int 2 AAUAANACAAA= \"Max Iterations\" Int 1 ZAAAAA== \"Camera Position\" Float 3 AAAAAM3MTD3NzEw+AAAAAA== \"Camera Direction\" Float 3 AACAPwAAAAAAAAAAAAAAAA== \"Camera Up\" Float 3 AAAAAAAAgD8AAAAAAAAAAA== \"Field Of View\" Float 1 AABIQg== \"AntiAliasing Samples\" Int 1 BAAAAA== \"Occlusion Samples\" Int 1 BgAAAA== \"Scene Epsilon\" Float 1 CtcjPA== \"Normal Epsilon\" Float 1 bxKDOg== \"User\" Float 9 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 11 \"resolution\" 2 1 \"iterations\" 1 1 \"camPos\" 3 1 \"camDir\" 3 1 \"camUp\" 3 1 \"fov\" 1 1 \"aa_samples\" 1 1 \"occlusion_samples\" 1 1 \"epsilon\" 1 1 \"normal_epsilon\" 1 1 \"user\" 1 9 4 \"MAX_DIST\" Float 1 1 AAAAAA== \"light_position\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"light_colour\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"light_strength\" Float 1 2 AAAAAAAAAAA="
 kernelSource "#include \"glsl_functions.h\"\n#include \"sdf_functions.h\"\n#include \"sdf_primitives.h\"\n\n///**** TODO ****\n// * Define camera via rotation angles\n// * Antialias\n// * Shadows\n// * Make the scene the foundry logo?\n// * Check the cool posts about magnetic pole stuff I found ages ago\n\nkernel TestKernel : ImageComputationKernel<ePixelWise>\n\{\n\t// No input data needed\n\tImage<eWrite, eAccessPoint, eEdgeNone> dst;\n\n\tparam:\n\tint2 resolution;\n\tint iterations;\n\t\n\tfloat3 camPos;\n\tfloat3 camDir;\n\tfloat3 camUp;\n\tfloat fov;\n\n\tint aa_samples;\n\tint occlusion_samples;\n\n\tfloat epsilon;\n\tfloat normal_epsilon;\n\n\tfloat user\[9];\n\n\tvoid define()\n\t\{\n\t\tdefineParam(resolution, \"Image Resolution\", int2(1280, 720) );\n\t\tdefineParam(iterations, \"Max Iterations\", 100);\n\n\t\tdefineParam(camPos, \"Camera Position\", float3(0.0f, 0.05f, 0.2f) );\n\t\tdefineParam(camDir, \"Camera Direction\", float3(1.0f, 0.0f, 0.0f) );\n\t\tdefineParam(camUp, \"Camera Up\", float3(0.0f, 1.0f, 0.0f) );\n\n\t\tdefineParam(fov, \"Field Of View\", 50.0f);\n\n\t\tdefineParam(aa_samples, \"AntiAliasing Samples\", 4);\n\t\tdefineParam(occlusion_samples, \"Occlusion Samples\", 6);\n\n\t\tdefineParam(epsilon, \"Scene Epsilon\", 0.01f);\n\t\tdefineParam(normal_epsilon, \"Normal Epsilon\", 0.001f);\n\n\t\t// Convenience for scene editing\n\t\tdefineParam(user, \"User\");\n\t\}\n\n\tlocal:\n\t// Careful, these constants don't seem to be properly initialised\n\tconst float MAX_DIST = 9999999.9f;\n\t\n\tstatic const int MAX_LIGHTS = 2;\n\tfloat3 light_position\[MAX_LIGHTS];\n\tfloat3 light_colour\[MAX_LIGHTS];\n\tfloat light_strength\[MAX_LIGHTS];\n\t\n\tvoid init()\n\t\{\n\t\tlight_position\[0]   = float3(3.0f, -8.0f, -1.0f);\n\t\tlight_colour\[0] \t= float3(230 / 255.0f, 230 / 255.0f, 250 / 255.0f);\n\t\tlight_strength\[0]\t= 180.0f;\n\n\t\tlight_position\[1]   = float3(-3.0f, 3.0f, -4.0f);\n\t\tlight_colour\[1] \t= float3(255 / 255.0f, 228 / 255.0f, 196 / 255.0f);\n\t\tlight_strength\[1]\t= 40.0f;\n\t\}\n\n\t// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\tfloat rand(float2 _co)\n\t\{\n \t   return fract(sin(dot(_co , float2(12.9898f, 78.233f))) * 43758.5453f);\n\t\}\n\n\tfloat intersectScene(float3 _p)\n\t\{\n\t\tfloat3 p = _p;\n\t\tfloat d1 = sdPlane(p, float4(0.0f, 1.0f, 0.0f, 0.0f) );\n\t\t\n\t\tp = p - float3(0.0f, user\[1], 0.0f);\n\t\tp = repeatXYZ(p, float3(user\[0], user\[0], user\[0]) );\n\t\t// float d2 = sdSphere(p, 0.1f);\n\t\tfloat d2 = sdBox(p, float3(0.1f) );\n\t\t\n\t\treturn min(d1,d2);\n\t\}\n\n\t\t// Classic AO\n\t// http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\n\tfloat classicOcclusion(float3 _p, float3 _n, float _maxDist, float _falloff)\n\t\{\n\t\tfloat ao = 0.0f;\n\n\t\tfor(int i = 0; i < occlusion_samples; i++)\n\t\t\{\n\t\t\tfloat l = rand(float(i)) * _maxDist; // Randomly sized sample\n\t\t\tfloat3 rayDir = _n * l;\n\n\t\t\tao += (l - intersectScene(_p + rayDir)) / pow(1.0f + l, _falloff);\n\t\t\}\n\n\t\treturn clamp( 1.0f - ao / float(occlusion_samples), 0.0f, 1.0f);\n\t\}\n\n\t// http://psgraphics.blogspot.co.uk/2014/11/making-orthonormal-basis-from-unit.html\n\t// float3 createFrisvadONB(float3 _dir, float _i)\n\t// \{\n\t// \tif( )\n\t// \}\n\n\t// http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\n\tfloat3 randomSphereDir(float2 _rnd)\n\t\{\n\t\tfloat s = _rnd.x * PI * 2.0f;\n\t\tfloat t = _rnd.y * 2.0 - 1.0f;\n\t\treturn float3( sin(s), cos(s), t) / sqrt(1.0f + t * t);\n\t\}\n\n\tfloat3 randomHemisphereDir(float3 _dir, float _i)\n\t\{\n\t\tfloat3 v = randomSphereDir( float2(rand(_i+1.0f), rand(_i + 2.0f)) );\n\t\treturn v * sign(dot(v, _dir));\n\t\}\n\n\tfloat hemisphericalOcclusion(float3 _p, float3 _n, float _maxDist, float _falloff)\n\t\{\n\t\tfloat ao = 0.0f;\n\t\tconst float inverseOcclusionSamples = 1.0f / float(occlusion_samples);\n\t\tconst float rad = 1.0f * -1.0f * inverseOcclusionSamples;\n\n\t\tfor(int i = 0; i < occlusion_samples; i++)\n\t\t\{\n\t\t\tfloat l = rand(float(i)) * _maxDist; // Randomly sized sample\n\t\t\tfloat3 rayDir = normalize(_n + randomHemisphereDir(_n,l) * rad) * l;\n\n\t\t\tao += (l - intersectScene(_p + rayDir)) / pow(1.0f + l, _falloff);\n\t\t\}\n\n\t\treturn clamp( 1.0f - ao / float(occlusion_samples), 0.0f, 1.0f);\n\t\}\n\n\t// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n\tfloat shadow(float3 _ro, float3 _rd, float _mint, float _maxt)\n\t\{\n\t\tfor(float t = _mint; t < _maxt; )\n\t\t\{\n\t\t\tfloat h = intersectScene(_ro + _rd*t);\n\t\t\tif(h < 0.001)\n\t\t\t\{\n\t\t\t\treturn 0.0f;\n\t\t\t\}\n\t\t\tt += h;\n\t\t\}\n\n\t\treturn 1.0f;\n\t\}\n\n\n\tfloat3 shade(float3 _p, float3 _n)\n\t\{\n\t\t// Back step the normal\n\t\t_p = _p + (-0.01f * _n);\n\n\t\tfloat3 radiance = float3(0.0f, 0.0f, 0.0f);\n\n\t\tfor(int i = 0; i < MAX_LIGHTS; i++)\n\t\t\{\n\t\t\tfloat3 light_path = _p - light_position\[i];\n\t\t\tfloat3 light_dir = normalize(light_path);\n\t\t\tfloat attenuation = 1.0f / pow(length(light_path), 2);\n\t\t\tfloat diffuse = dot(normalize(_n), light_dir);\n\n\t\t\tfloat shadowed = shadow(light_path, light_dir, user\[6], user\[7]);\n\n\t\t\tradiance += (diffuse * light_colour\[i] * light_strength\[i] * attenuation) * shadowed;\n\t\t\}\n\n\t\treturn radiance * hemisphericalOcclusion(_p, _n, user\[3], user\[4]);\n\t\}\n\n\t// float estimate_occlusion(float3 _p, float3 _n)\n\t// \{\n\n\t// \}\n\n\tfloat3 estimate_normal(float3 _p)\n\t\{\n\t\tfloat3 dx = float3(normal_epsilon, 0.0f, 0.0f);\n\t\tfloat3 dy = float3(0.0f, normal_epsilon, 0.0f);\n\t\tfloat3 dz = float3(0.0f, 0.0f, normal_epsilon);\n\n\t\treturn normalize(float3(\n\t\t\t\tintersectScene(_p + dx) - intersectScene(_p - dx),\n\t\t\t\tintersectScene(_p + dy) - intersectScene(_p - dy),\n\t\t\t\tintersectScene(_p + dz) - intersectScene(_p - dz)\n\t\t\t));\n\t\}\n\n\tfloat3 cameraRay(float2 _fragcoord, float3 _camPos, float3 _camDir, float3 _camUp, float _fov)\n\t\{\n\t\t_camDir = normalize(_camDir);\n\t\tfloat3 right = _camDir;//float3(1.0f, 0.0f, 0.0f);\n\t\tfloat3 forward = cross(_camUp, right );\n\n\t\tfloat aspect = float(resolution.x) / float(resolution.y);\n\t\tfloat u = aspect * (_fragcoord.x * 2.0f / resolution.x - 1.0f);\n\t\tfloat v = (_fragcoord.y * 2.0f / resolution.y - 1.0f);\n\t\tfloat fov_ratio = (0.5f*aspect) / (tan(radians(fov * 0.5f)));\n\n\t\tfloat3 rayOrigin = _camPos;\n\t\tfloat3 rayDir = normalize( forward*fov_ratio + right*u + _camUp*v );\n\n\t\treturn rayDir;\n\t\}\n\n\tfloat3 traceWorld(float3 _p, float3 _dir)\n\t\{\n\t\tfloat dist = 0.0f;\n\t\t\n\t\tfor(int i = 0; i < iterations; ++i)\n\t\t\{\n\t\t\tfloat3 hit = _p + (dist*_dir);\n\t\t\tfloat t = intersectScene( hit );\n\n\t\t\tif(t < epsilon)\n\t\t\t\{\n\t\t\t\tfloat3 nrm = estimate_normal(hit);\n\t\t\t\treturn shade(hit, nrm);\n\t\t\t\}\n\n\t\t\tdist += t;\n\t\t\}\n\n\t\treturn float3(0.2f, 0.2f, 0.2f);\n\t\}\n\n\tvoid process(int2 pos)\n\t\{\n\t\tfloat3 colour = float3(0.0f, 0.0f, 0.0f);\n\n\t\t// By the way, I'm not sure about all GPUs, but a lot aren't fond of nesting things inside the loop. Taking the lighting calculations outside the main raymarching loop produces a noticeable (20fps to 60fps) framerate increase on the machine I'm currently on, and, I'd imagine, on a lot of other people's also.\n\t\t// https://www.shadertoy.com/view/MdVSz1\n\t\tfloat3 ro = camPos;\n\t\tfloat2 uv = float2(pos.x, pos.y);\n\t\tfor(int j=0; j<aa_samples; j++)\n\t\t\{\n\t\t\tfloat2 random_sample = rand( uv + (float2(j,j) * 0.1f) );\n\n\t\t\tfloat3 rd = cameraRay(uv + random_sample, camPos, camDir, camUp, fov);\n\t\t\tcolour += traceWorld(ro, rd);\n\t\t\}\n\t\tcolour /= aa_samples;\n\n\t\tdst() = float4(colour.x, colour.y, colour.z, 1.0);\n\t\}\n\};"
 rebuild ""
 "TestKernel_Camera Position" {0 0.14 1.94}
 "TestKernel_Camera Up" {0 1 -0.17}
 "TestKernel_Occlusion Samples" 10
 "TestKernel_Scene Epsilon" 0.001
 "TestKernel_Normal Epsilon" 0.005
 group_TestKernel_User 1
 TestKernel_User {
     {0.46 -0.27 0}
     {1.75 0.08 0}
     {0 0.78 0}
   }
 rebuild_finalise ""
 name BlinkScript1
 selected true
 xpos -225
 ypos -56
}
Viewer {
 frame 1
 frame_range 1-100
 name Viewer1
 xpos -225
 ypos 48
}
